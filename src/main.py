#!/usr/bin/env python3
"""
Python Project Generator CLI
A tool to scaffold different types of Python projects with best practices.
"""

import os
import sys
from pathlib import Path
from typing import Dict, List, Optional
from rich.console import Console
from rich.prompt import Prompt, Confirm
from rich.panel import Panel
from rich.table import Table
from rich import box

console = Console()


class ProjectTemplate:
    """Base class for project templates"""
    
    def __init__(self, project_name: str, project_path: Path):
        self.project_name = project_name
        self.project_path = project_path
        self.common_folders = [
            "notebooks",
            "artifacts/wip",
            "artifacts/completed",
            "reports",
            "research",
            "quality",
            "scripts",
            "data",
            "tests"
        ]
    
    def create_folder_structure(self, additional_folders: Optional[List[str]] = None):
        """Create common folder structure"""
        folders = self.common_folders + (additional_folders or [])
        for folder in folders:
            (self.project_path / folder).mkdir(parents=True, exist_ok=True)
            # Add .gitkeep files
            (self.project_path / folder / ".gitkeep").touch()
    
    def create_pyproject_toml(self, dependencies: List[str]):
        """Create pyproject.toml for uv"""
        # Format dependencies as a proper list without extra quotes
        deps_formatted = ",\n    ".join(dependencies)
        
        content = f'''[project]
name = "{self.project_name}"
version = "0.1.0"
description = "A Python project generated by project-generator"
readme = "README.md"
requires-python = ">=3.10"
dependencies = [
    {deps_formatted}
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.build.targets.wheel]
packages = ["src"]

[dependency-groups]
dev = [
    "pytest>=7.4.0",
    "pytest-cov>=4.1.0",
    "black>=23.7.0",
    "ruff>=0.0.285",
    "ipykernel>=7.1.0",
]
'''
        with open(self.project_path / "pyproject.toml", "w") as f:
            f.write(content)
    
    def create_gitignore(self):
        """Create .gitignore file"""
        content = '''# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
venv/
.venv/
ENV/
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Testing
.pytest_cache/
.coverage
htmlcov/

# IDEs
.vscode/
.idea/
*.swp
*.swo
*~

# Data
data/raw/*
data/processed/*
!data/raw/.gitkeep
!data/processed/.gitkeep

# Notebooks
.ipynb_checkpoints/

# Environment
.env
.env.local

# OS
.DS_Store
Thumbs.db
'''
        with open(self.project_path / ".gitignore", "w") as f:
            f.write(content)
    
    def create_readme(self, content: str):
        """Create README.md"""
        with open(self.project_path / "README.md", "w") as f:
            f.write(content)
    
    def create_basic_test(self):
        """Create a basic test file"""
        content = '''"""Basic tests for the project"""
import pytest


def test_project_structure():
    """Test that project structure is correct"""
    import os
    from pathlib import Path
    
    project_root = Path(__file__).parent.parent
    expected_dirs = ["notebooks", "artifacts", "reports", "research", "quality", "scripts", "data"]
    
    for dir_name in expected_dirs:
        assert (project_root / dir_name).exists(), f"Missing directory: {dir_name}"


def test_placeholder():
    """Placeholder test"""
    assert True
'''
        with open(self.project_path / "tests" / "test_basic.py", "w") as f:
            f.write(content)
        
        # Create __init__.py
        (self.project_path / "tests" / "__init__.py").touch()
    
    def create_src_init(self):
        """Create src/__init__.py to make it a proper package"""
        (self.project_path / "src" / "__init__.py").write_text(
            f'"""{self.project_name} package."""\n'
        )


class RAGAgentTemplate(ProjectTemplate):
    """Template for RAG Agent with LangChain"""
    
    def generate(self):
        console.print("[cyan]Creating RAG Agent project...[/cyan]")
        
        # Create folders
        self.create_folder_structure(["src", "src/agents", "src/vectorstore", "streamlit_app"])
        
        # Dependencies (without extra quotes)
        deps = [
            '"langchain>=0.1.0"',
            '"langchain-community>=0.0.20"',
            '"streamlit>=1.29.0"',
            '"qdrant-client>=1.7.0"',
            '"ollama>=0.1.0"',
            '"python-dotenv>=1.0.0"',
            '"sentence-transformers>=2.2.0"',
        ]
        self.create_pyproject_toml(deps)
        
        # Create main app structure
        self._create_streamlit_app()
        self._create_agent_module()
        self._create_data_generation_script()
        self._create_env_example()
        self.create_src_init()
        
        # Create README
        readme = f'''# {self.project_name}

A RAG (Retrieval-Augmented Generation) agent built with LangChain and Streamlit.

## Setup

1. Install dependencies using uv:
```bash
uv sync
```

2. Copy `.env.example` to `.env` and configure your settings

3. Run the Streamlit app:
```bash
uv run streamlit run streamlit_app/app.py
```

## Project Structure

- `src/agents/` - Agent implementations
- `src/vectorstore/` - Vector database configuration
- `streamlit_app/` - Streamlit frontend
- `scripts/` - Utility scripts including data generation
- `notebooks/` - Jupyter notebooks for experimentation
- `data/` - Data storage
- `tests/` - Test suite

## Testing

Run tests with:
```bash
uv run pytest
```

## Architecture

This RAG agent uses:
- **LangChain** for agent orchestration
- **Qdrant** for vector storage
- **Ollama** for local LLM inference
- **Streamlit** for the web interface
'''
        self.create_readme(readme)
        self.create_gitignore()
        self.create_basic_test()
        
        console.print("[green]âœ“ RAG Agent project created successfully![/green]")
    
    def _create_streamlit_app(self):
        content = '''import streamlit as st
from pathlib import Path
import sys

# Add src to path
sys.path.insert(0, str(Path(__file__).parent.parent / "src"))

st.set_page_config(page_title="RAG Agent", page_icon="ðŸ¤–", layout="wide")

# Sidebar
with st.sidebar:
    st.title("ðŸ¤– RAG Agent")
    st.markdown("---")
    
    # Configuration options
    st.subheader("Configuration")
    model = st.selectbox("Model", ["llama2", "mistral", "codellama"])
    temperature = st.slider("Temperature", 0.0, 1.0, 0.7)
    
    st.markdown("---")
    if st.button("Clear Chat History"):
        st.session_state.messages = []
        st.rerun()

# Initialize chat history
if "messages" not in st.session_state:
    st.session_state.messages = []

# Display chat messages
for message in st.session_state.messages:
    with st.chat_message(message["role"]):
        st.markdown(message["content"])

# Chat input
if prompt := st.chat_input("Ask me anything..."):
    # Add user message
    st.session_state.messages.append({"role": "user", "content": prompt})
    with st.chat_message("user"):
        st.markdown(prompt)
    
    # Generate response (placeholder)
    with st.chat_message("assistant"):
        response = f"Echo: {prompt}"  # Replace with actual agent logic
        st.markdown(response)
    
    st.session_state.messages.append({"role": "assistant", "content": response})
'''
        with open(self.project_path / "streamlit_app" / "app.py", "w") as f:
            f.write(content)
    
    def _create_agent_module(self):
        content = '''"""RAG Agent implementation"""
from langchain.chains import RetrievalQA
from langchain.vectorstores import Qdrant
from typing import Optional


class RAGAgent:
    """Main RAG Agent class"""
    
    def __init__(self, model_name: str = "llama2"):
        self.model_name = model_name
        self.vectorstore: Optional[Qdrant] = None
        
    def initialize_vectorstore(self, collection_name: str):
        """Initialize Qdrant vector store"""
        # TODO: Implement Qdrant initialization
        pass
    
    def query(self, question: str) -> str:
        """Query the RAG agent"""
        # TODO: Implement query logic
        return f"Response to: {question}"
'''
        with open(self.project_path / "src" / "agents" / "rag_agent.py", "w") as f:
            f.write(content)
        
        (self.project_path / "src" / "agents" / "__init__.py").touch()
    
    def _create_data_generation_script(self):
        content = '''#!/usr/bin/env python3
"""
Data generation script for creating synthetic data for the RAG system
"""
import json
from pathlib import Path


def generate_sample_documents(num_docs: int = 10):
    """Generate sample documents for testing"""
    documents = []
    
    for i in range(num_docs):
        doc = {
            "id": f"doc_{i}",
            "content": f"This is sample document {i} with some content.",
            "metadata": {
                "source": "generated",
                "index": i
            }
        }
        documents.append(doc)
    
    return documents


def main():
    """Main function"""
    output_dir = Path(__file__).parent.parent / "data"
    output_dir.mkdir(exist_ok=True)
    
    documents = generate_sample_documents()
    
    output_file = output_dir / "sample_documents.json"
    with open(output_file, "w") as f:
        json.dump(documents, f, indent=2)
    
    print(f"Generated {len(documents)} documents -> {output_file}")


if __name__ == "__main__":
    main()
'''
        with open(self.project_path / "scripts" / "generate_data.py", "w") as f:
            f.write(content)
    
    def _create_env_example(self):
        content = '''# Qdrant Configuration
QDRANT_URL=http://localhost:6333
QDRANT_API_KEY=

# Ollama Configuration
OLLAMA_BASE_URL=http://localhost:11434

# Model Settings
DEFAULT_MODEL=llama2
EMBEDDING_MODEL=all-MiniLM-L6-v2
'''
        with open(self.project_path / ".env.example", "w") as f:
            f.write(content)


class FastAPITemplate(ProjectTemplate):
    """Template for FastAPI Web API"""
    
    def generate(self):
        console.print("[cyan]Creating FastAPI project...[/cyan]")
        
        # Create folders
        self.create_folder_structure(["src", "src/api", "src/models", "src/services", "src/db"])
        
        # Dependencies (without extra quotes)
        deps = [
            '"fastapi>=0.104.0"',
            '"uvicorn[standard]>=0.24.0"',
            '"sqlalchemy>=2.0.0"',
            '"alembic>=1.12.0"',
            '"pydantic>=2.4.0"',
            '"pydantic-settings>=2.0.0"',
            '"python-jose[cryptography]>=3.3.0"',
            '"passlib[bcrypt]>=1.7.4"',
            '"python-multipart>=0.0.6"',
        ]
        self.create_pyproject_toml(deps)
        
        # Create app structure
        self._create_main_app()
        self._create_dockerfile()
        self._create_docker_compose()
        self.create_src_init()
        
        # Create README
        readme = f'''# {self.project_name}

A FastAPI web application with database integration and authentication.

## Setup

1. Install dependencies:
```bash
uv sync
```

2. Run the development server:
```bash
uv run uvicorn src.main:app --reload
```

3. Access the API documentation:
- Swagger UI: http://localhost:8000/docs
- ReDoc: http://localhost:8000/redoc

## Docker Deployment

Build and run with Docker:
```bash
docker-compose up --build
```

## Project Structure

- `src/api/` - API endpoints
- `src/models/` - Database models
- `src/services/` - Business logic
- `src/db/` - Database configuration
- `tests/` - Test suite

## Testing

```bash
uv run pytest
```
'''
        self.create_readme(readme)
        self.create_gitignore()
        self.create_basic_test()
        
        console.print("[green]âœ“ FastAPI project created successfully![/green]")
    
    def _create_main_app(self):
        content = '''from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI(
    title="API",
    description="A FastAPI application",
    version="0.1.0"
)

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/")
def read_root():
    return {"message": "Welcome to the API"}

@app.get("/health")
def health_check():
    return {"status": "healthy"}
'''
        with open(self.project_path / "src" / "main.py", "w") as f:
            f.write(content)
        
        (self.project_path / "src" / "api" / "__init__.py").touch()
        (self.project_path / "src" / "models" / "__init__.py").touch()
        (self.project_path / "src" / "services" / "__init__.py").touch()
        (self.project_path / "src" / "db" / "__init__.py").touch()
    
    def _create_dockerfile(self):
        content = '''FROM python:3.11-slim

WORKDIR /app

# Install uv
COPY --from=ghcr.io/astral-sh/uv:latest /uv /usr/local/bin/uv

# Copy project files
COPY pyproject.toml ./
COPY src ./src

# Install dependencies
RUN uv sync --frozen

# Expose port
EXPOSE 8000

# Run the application
CMD ["uv", "run", "uvicorn", "src.main:app", "--host", "0.0.0.0", "--port", "8000"]
'''
        with open(self.project_path / "Dockerfile", "w") as f:
            f.write(content)
    
    def _create_docker_compose(self):
        content = '''version: '3.8'

services:
  api:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://user:password@db:5432/dbname
    depends_on:
      - db
    volumes:
      - ./src:/app/src
    
  db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=dbname
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
'''
        with open(self.project_path / "docker-compose.yml", "w") as f:
            f.write(content)


class DataScienceTemplate(ProjectTemplate):
    """Template for Data Science/ML projects"""
    
    def generate(self):
        console.print("[cyan]Creating Data Science project...[/cyan]")
        
        # Create folders
        self.create_folder_structure([
            "src",
            "src/data",
            "src/features",
            "src/models",
            "models",
            "data/raw",
            "data/processed",
        ])
        
        # Dependencies (without extra quotes)
        deps = [
            '"numpy>=1.24.0"',
            '"pandas>=2.0.0"',
            '"scikit-learn>=1.3.0"',
            '"matplotlib>=3.7.0"',
            '"seaborn>=0.12.0"',
            '"jupyter>=1.0.0"',
            '"jupyterlab>=4.0.0"',
            '"fastapi>=0.104.0"',
            '"uvicorn[standard]>=0.24.0"',
            '"joblib>=1.3.0"',
        ]
        self.create_pyproject_toml(deps)
        
        # Create project files
        self._create_data_pipeline()
        self._create_model_training()
        self._create_api_server()
        self.create_src_init()
        
        # Create README
        readme = f'''# {self.project_name}

A Data Science and Machine Learning project with end-to-end pipeline.

## Setup

1. Install dependencies:
```bash
uv sync
```

2. Launch Jupyter Lab:
```bash
uv run jupyter lab
```

## Project Structure

- `src/data/` - Data loading and processing
- `src/features/` - Feature engineering
- `src/models/` - Model training and evaluation
- `models/` - Saved model artifacts
- `notebooks/` - Jupyter notebooks for exploration
- `data/` - Data storage (raw and processed)

## Workflow

1. **Data Ingestion**: Load and explore data in notebooks
2. **Feature Engineering**: Create features using scripts in `src/features/`
3. **Model Training**: Train models using `src/models/train.py`
4. **Deployment**: Serve model via FastAPI

## Model API

Start the model serving API:
```bash
uv run python src/models/serve.py
```

## Testing

```bash
uv run pytest
```
'''
        self.create_readme(readme)
        self.create_gitignore()
        self.create_basic_test()
        
        console.print("[green]âœ“ Data Science project created successfully![/green]")
    
    def _create_data_pipeline(self):
        content = '''"""Data loading and processing utilities"""
import pandas as pd
from pathlib import Path


def load_data(filepath: str) -> pd.DataFrame:
    """Load data from file"""
    path = Path(filepath)
    
    if path.suffix == '.csv':
        return pd.read_csv(filepath)
    elif path.suffix in ['.xlsx', '.xls']:
        return pd.read_excel(filepath)
    else:
        raise ValueError(f"Unsupported file type: {path.suffix}")


def preprocess_data(df: pd.DataFrame) -> pd.DataFrame:
    """Basic preprocessing"""
    # Remove duplicates
    df = df.drop_duplicates()
    
    # Handle missing values (placeholder)
    df = df.fillna(df.mean(numeric_only=True))
    
    return df
'''
        with open(self.project_path / "src" / "data" / "loader.py", "w") as f:
            f.write(content)
        
        (self.project_path / "src" / "data" / "__init__.py").touch()
        (self.project_path / "src" / "features" / "__init__.py").touch()
        (self.project_path / "src" / "models" / "__init__.py").touch()
    
    def _create_model_training(self):
        content = '''"""Model training script"""
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
import joblib
from pathlib import Path


def train_model(X, y, model_path: str = "models/model.joblib"):
    """Train a model and save it"""
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
    
    model = RandomForestClassifier(n_estimators=100, random_state=42)
    model.fit(X_train, y_train)
    
    score = model.score(X_test, y_test)
    print(f"Model accuracy: {score:.4f}")
    
    # Save model
    Path(model_path).parent.mkdir(exist_ok=True)
    joblib.dump(model, model_path)
    print(f"Model saved to {model_path}")
    
    return model


if __name__ == "__main__":
    # Example usage
    from sklearn.datasets import make_classification
    X, y = make_classification(n_samples=1000, n_features=20, random_state=42)
    train_model(X, y)
'''
        with open(self.project_path / "src" / "models" / "train.py", "w") as f:
            f.write(content)
    
    def _create_api_server(self):
        content = '''"""Model serving API"""
from fastapi import FastAPI
from pydantic import BaseModel
import joblib
from pathlib import Path

app = FastAPI(title="ML Model API")

# Load model (placeholder)
MODEL_PATH = Path(__file__).parent.parent.parent / "models" / "model.joblib"
model = None

@app.on_event("startup")
def load_model():
    global model
    if MODEL_PATH.exists():
        model = joblib.load(MODEL_PATH)
    else:
        print("Model not found. Train a model first.")

class PredictionInput(BaseModel):
    features: list

class PredictionOutput(BaseModel):
    prediction: int
    probability: float

@app.post("/predict", response_model=PredictionOutput)
def predict(input_data: PredictionInput):
    if model is None:
        return {"error": "Model not loaded"}
    
    prediction = model.predict([input_data.features])[0]
    probability = float(max(model.predict_proba([input_data.features])[0]))
    
    return PredictionOutput(prediction=int(prediction), probability=probability)

@app.get("/health")
def health():
    return {"status": "healthy", "model_loaded": model is not None}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
'''
        with open(self.project_path / "src" / "models" / "serve.py", "w") as f:
            f.write(content)


class AutomationTemplate(ProjectTemplate):
    """Template for Task Automation and Scripting"""
    
    def generate(self):
        console.print("[cyan]Creating Automation project...[/cyan]")
        
        # Create folders
        self.create_folder_structure(["src", "src/tasks", "logs"])
        
        # Dependencies (without extra quotes)
        deps = [
            '"click>=8.1.0"',
            '"requests>=2.31.0"',
            '"beautifulsoup4>=4.12.0"',
            '"python-dotenv>=1.0.0"',
            '"schedule>=1.2.0"',
            '"pyyaml>=6.0"',
        ]
        self.create_pyproject_toml(deps)
        
        # Create project files
        self._create_cli_interface()
        self._create_example_tasks()
        self.create_src_init()
        
        # Create README
        readme = f'''# {self.project_name}

A Python automation and scripting project for repetitive tasks.

## Setup

1. Install dependencies:
```bash
uv sync
```

2. Run the CLI:
```bash
uv run python -m src.cli --help
```

## Project Structure

- `src/tasks/` - Individual automation tasks
- `scripts/` - Standalone scripts
- `logs/` - Task execution logs
- `data/` - Input/output data

## Usage

### Run a specific task:
```bash
uv run python -m src.cli run task-name
```

### List available tasks:
```bash
uv run python -m src.cli list
```

### Schedule a task:
```bash
uv run python -m src.cli schedule task-name --interval 3600
```

## Creating New Tasks

Add new tasks in `src/tasks/` by subclassing `Task`.

## Testing

```bash
uv run pytest
```
'''
        self.create_readme(readme)
        self.create_gitignore()
        self.create_basic_test()
        
        console.print("[green]âœ“ Automation project created successfully![/green]")
    
    def _create_cli_interface(self):
        content = '''#!/usr/bin/env python3
"""Main CLI interface for automation tasks"""
import click
from pathlib import Path
import importlib
import sys

@click.group()
def cli():
    """Task automation CLI"""
    pass

@cli.command()
def list():
    """List all available tasks"""
    tasks_dir = Path(__file__).parent / "tasks"
    click.echo("Available tasks:")
    for task_file in tasks_dir.glob("*.py"):
        if task_file.name != "__init__.py":
            click.echo(f"  - {task_file.stem}")

@cli.command()
@click.argument('task_name')
@click.option('--dry-run', is_flag=True, help='Simulate without executing')
def run(task_name, dry_run):
    """Run a specific task"""
    try:
        module = importlib.import_module(f"src.tasks.{task_name}")
        if hasattr(module, 'run'):
            click.echo(f"Running task: {task_name}")
            if dry_run:
                click.echo("[DRY RUN MODE]")
            module.run(dry_run=dry_run)
            click.echo("âœ“ Task completed")
        else:
            click.echo(f"Error: Task '{task_name}' has no run() function", err=True)
    except ModuleNotFoundError:
        click.echo(f"Error: Task '{task_name}' not found", err=True)

@cli.command()
@click.argument('task_name')
@click.option('--interval', default=3600, help='Interval in seconds')
def schedule(task_name, interval):
    """Schedule a task to run periodically"""
    click.echo(f"Scheduling '{task_name}' every {interval} seconds")
    # TODO: Implement scheduling logic
    click.echo("Note: Scheduling not yet implemented")

if __name__ == '__main__':
    cli()
'''
        with open(self.project_path / "src" / "cli.py", "w") as f:
            f.write(content)
    
    def _create_example_tasks(self):
        # File organizer task
        organizer_content = '''"""File organization task"""
from pathlib import Path
import shutil


def run(dry_run=False):
    """Organize files by extension"""
    source_dir = Path("data")
    
    if not source_dir.exists():
        print(f"Directory {source_dir} not found")
        return
    
    extensions = {}
    for file in source_dir.glob("*"):
        if file.is_file():
            ext = file.suffix or "no_extension"
            if ext not in extensions:
                extensions[ext] = []
            extensions[ext].append(file)
    
    for ext, files in extensions.items():
        target_dir = source_dir / ext.lstrip(".")
        print(f"Moving {len(files)} {ext} files to {target_dir}")
        
        if not dry_run:
            target_dir.mkdir(exist_ok=True)
            for file in files:
                shutil.move(str(file), str(target_dir / file.name))
'''
        with open(self.project_path / "src" / "tasks" / "file_organizer.py", "w") as f:
            f.write(organizer_content)
        
        # Web scraper task
        scraper_content = '''"""Web scraping task example"""
import requests
from bs4 import BeautifulSoup


def run(dry_run=False):
    """Scrape a website (example)"""
    url = "https://example.com"
    
    print(f"Scraping: {url}")
    
    if dry_run:
        print("[DRY RUN] Would fetch and parse the page")
        return
    
    try:
        response = requests.get(url, timeout=10)
        response.raise_for_status()
        
        soup = BeautifulSoup(response.content, 'html.parser')
        title = soup.find('title')
        
        print(f"Page title: {title.string if title else 'No title found'}")
    except Exception as e:
        print(f"Error: {e}")
'''
        with open(self.project_path / "src" / "tasks" / "web_scraper.py", "w") as f:
            f.write(scraper_content)
        
        (self.project_path / "src" / "tasks" / "__init__.py").touch()


def display_welcome():
    """Display welcome message"""
    console.print(Panel.fit(
        "[bold cyan]Python Project Generator[/bold cyan]\n"
        "[dim]Generate well-structured Python projects with best practices[/dim]",
        border_style="cyan"
    ))


def display_project_types():
    """Display available project types"""
    table = Table(title="Available Project Types", box=box.ROUNDED)
    table.add_column("Type", style="cyan", no_wrap=True)
    table.add_column("Description", style="white")
    
    table.add_row(
        "1. RAG Agent",
        "LangChain-based RAG agent with Streamlit UI, Qdrant, and Ollama"
    )
    table.add_row(
        "2. FastAPI Web API",
        "REST API with FastAPI, database integration, and Docker support"
    )
    table.add_row(
        "3. Data Science/ML",
        "ML project with scikit-learn, pandas, and model serving API"
    )
    table.add_row(
        "4. Task Automation",
        "Scripting and automation with CLI interface"
    )
    
    console.print(table)


def main():
    """Main function"""
    display_welcome()
    console.print()
    display_project_types()
    console.print()
    
    # Get project type
    project_type = Prompt.ask(
        "[cyan]Select project type[/cyan]",
        choices=["1", "2", "3", "4"],
        default="1"
    )
    
    # Get project name
    project_name = Prompt.ask(
        "[cyan]Enter project name[/cyan]",
        default="my_project"
    )
    
    # Validate project name
    if not project_name.replace("_", "").replace("-", "").isalnum():
        console.print("[red]Error: Project name should contain only letters, numbers, hyphens, and underscores[/red]")
        return
    
    # Get project path
    default_path = Path.cwd() / project_name
    path_input = Prompt.ask(
        "[cyan]Enter project path[/cyan]",
        default=str(default_path)
    )
    project_path = Path(path_input)
    
    # Check if directory exists
    if project_path.exists():
        overwrite = Confirm.ask(
            f"[yellow]Directory {project_path} already exists. Overwrite?[/yellow]",
            default=False
        )
        if not overwrite:
            console.print("[yellow]Operation cancelled[/yellow]")
            return
    
    # Create project directory
    project_path.mkdir(parents=True, exist_ok=True)
    
    # Generate project based on type
    templates = {
        "1": RAGAgentTemplate,
        "2": FastAPITemplate,
        "3": DataScienceTemplate,
        "4": AutomationTemplate
    }
    
    template_class = templates[project_type]
    template = template_class(project_name, project_path)
    
    try:
        template.generate()
        
        # Display success message
        console.print()
        console.print(Panel.fit(
            f"[bold green]âœ“ Project created successfully![/bold green]\n\n"
            f"[cyan]Location:[/cyan] {project_path}\n"
            f"[cyan]Next steps:[/cyan]\n"
            f"  1. cd {project_name}\n"
            f"  2. uv sync\n"
            f"  3. Read the README.md for more information",
            border_style="green",
            title="Success"
        ))
        
    except Exception as e:
        console.print(f"[red]Error creating project: {e}[/red]")
        import traceback
        console.print(traceback.format_exc())


if __name__ == "__main__":
    main()